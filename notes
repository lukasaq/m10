########## mod 10 lesson 1 ###############
######### switching ##########
Introduction to Switching ###############
Switches operate at Layer 2 of the OSI model,

Traversal between networks is handled on Layer 3 of the OSI model,

Layer 2 of the OSI model — the Data Link layer — handles addressing ethernet frames to direct communication between hosts on the same Local Area Network (LAN). Ethernet frames include Layer 2 addressing with vendor-assigned unique source and destination addresses for segments. In addition, ethernet commonly uses MAC addresses for communication on a segment. Other Layer 2 protocols — such as Frame Relay — use a completely different method of Layer 2 addressing.

MAC addresses are unique 48-bit addresses, separated into six octets, and noted in hexadecimal format. The first three octets — known as the Organizationally Unique Identifiers (OUI) 

Layer 2 Devices ##################
simplest Layer 2 device for ethernet networks that allows multiple devices to communicate with each other is the hub. These devices broadcast all received data frames to all ports, regardless of the intended recipient. While these simple devices may still be found in some older networks, their usage is discouraged due to issues that they present including:
- The broadcast behavior allows any connected device to view traffic bound for any other device on the hub.

- Due to the rebroadcast nature of this device, transmitted frames can often collide when two connected devices attempt to send at the same time — especially during high-traffic load — causing dropped frames or retransmissions.


HUBS: one brodcast domain and one collison domain


switches allow for connectivity between devices; however, unlike hubs, switches utilize logic to determine which ports to forward frames onto. Switching logic and MAC address tables are covered later in this lesson.

Basic switches exist that perform only the bare minimum of switching to ensure that collisions do not occur frequently and ensure basic addressing. These switches — sometimes referred to as unmanaged switches — can be found in small business and home networks and even see use in enterprise networks. However, managed switches are typically utilized in enterprise networks, especially for central connectivity within the network. These switches are able to be configured and support more features — such as the ability to mirror ports, create VLANs to segregate networks, etc.

Cisco Devices ###################

Cisco devices tend to have several different methods for an administrator to connect to them. The most common methods follow:
 
- Direct connection to the console via the console or Auxiliary (AUX) port. This is generally a serial port connection and often requires the included Registered Jack (RJ)-45 to Recommended Standard (RS)-232 cable to connect to. The screen command or a terminal emulator can be used on Linux, while PuTTY or other terminal connection software is common on Windows.

- Connection to a virtual console, typically via Secure Shell (SSH) or Teletype Network (Telnet). Telnet is generally discouraged because its traffic is transmitted in plaintext. Binaries for SSH are available or commonly included on Linux systems and modern builds of Windows — though, PuTTY is still commonly used on Windows.

- Many modern Cisco devices also include web interfaces for viewing the status of and managing the device. These interfaces can be interacted with using standard browsers.


Cisco Security Model ############# 



Privilege level 0 is the lowest level privilege defined by default on Cisco devices. When connected with privilege level 0, the connected user only has access to these commands:
disable: Lower privilege level
enable: Raise privilege level
exit: Close the current session
help: Interact with the help system
logout: Close the current session


User
Privilege level 1. At this level — in addition to the above commands — some additional utilities are available for troubleshooting connectivity, such as the traceroute and ping commands. In addition, some configurations can be viewed via show commands. No configuration changes can be made at this level.


Privileged
Privilege level 15 is the highest level defined by default on Cisco devices. At this privilege level, all commands are available, and the device can be configured.

Cisco Configuration Mode ###########
make changes to the current configuration of the device, the configure terminal command must be used. For this command to be used, the current privilege level must be 15 (Privileged). As the configuration is navigated, the prompt changes to indicate what is currently being configured:

This section covers the version of the device, as well as some services that are configured:

- version: Indicates the Cisco Internetwork Operating System (IOS) version for this device
- service timestamps: Determines how timestamps for debug and log entries are displayed
- service password-encryption: Automatically encrypts passwords when a new password is saved; no variant of the command means this is disabled
- service compress-config: Configuration is compressed automatically by this service

hostname: Sets the hostname for this device; shown in the command-line by default, may also be discovered by this name, or respond with this name during network discovery
aaa new-model: Authentication, Authorization, and Accounting (AAA); disabled, this device does not support AAA features, such as user accounts, user levels, or command-level logging as handled by the AAA feature
spanning-tree mode: Determines the method used for Spanning Tree Protocol (STP
vlan internal allocation policy: Specific VLANs reserved for internal use — determines where these VLANs begin enumerating (ascending starts at VLAN Identifier [ID] 1006 and up, descending at 4095 and below)
interface: GigabitEthernet1/3 here indicates that this device is detected as a gigabit ethernet interface (as opposed to FastEthernet for 100 megabit ethernet) in slot zero, port zero; each internal slot may or may not contain multiple ports, depending on the interface card
media-type: RJ-45, Small Form-factor Pluggable (SFP), or Auto
shutdown: Port is administratively disabled, ensuring that the port is not usable
line vty: Five (0, 1, 2, 3, 4) virtual terminals (used for SSH or Telnet) are enabled. Unlike con and AUX ports, these are not physical.


VLANs are defined in the IEEE 802.1Q standard, which states that 32 bits are allocated in the ethernet packet header for the following fields:
Tag Protocol Identifier (TPID): 16-bit field set to 0x8100 to identify the 802.1Q packetPriority Code Point (PCP): 3-bit Class of Service (CoS) field; assigned to Layer 2 QoS between switchesDrop Eligible Indicator (DEI): 1-bit field indicating whether the packet can be dropped when insufficient bandwidth is available on a link; when identified, indicates the potential use of Voice over IP (VoIP) trafficVLAN ID: 12-bit field specifying the VLAN associated with a network packet


LAN traversal happens via routing on Layer 3 — so-called Layer 3 switches are able to control and allow machines on different VLANs to communicate with each other in a manner managed by the switch.

Private VLANs further subdivide VLANs, allowing for isolation of devices within a VLAN from each other. When assigning a private VLAN to a port, in addition to the primary VLAN, a community VLAN ID is required. Three types of private VLAN ports exist:

Promiscuous Typically reserved for routers or other gateway devices, these ports can receive traffic from any of the ports in a VLAN, regardless of the private VLAN configurations of those devices.

Isolated Only able to communicate with promiscuous ports, these ports are isolated from all other ports. However, communication with the primary VLAN is possible.

Community Able to communicate with promiscuous ports and other community ports on the same community VLAN. Additionally, community ports can communicate with the primary VLAN.

The default native VLAN for most switch vendors is VLAN 1.


Practical Implications #############
Switch configurations have practical implications for the security of a network. Some examples of attacks that rely on the behavior of switches or misconfigurations follow:

MAC Flooding This attack relies on switches having a limited amount of memory for storing the MAC address table, which is used to store MAC address-to-port associations. Due to the inability to store updates to this table, many switches failover to broadcast mode for all data frames — similar to network hubs. This allows an attacker physically attached to a switch to view all traffic passing through the switch, rather than just traffic intended to be bound for that machine.

MAC Spoofing This attack merely has the attacker present a different MAC address to the switch than the actual hardware MAC. This can be done for various reasons, such as bypassing MAC filters, masquerading as a legitimate device, or evading information gathering by masquerading as a different device.

VLAN Hopping This attack — accomplished via a handful of methods — allows the attacker to view or transmit to or from VLANs that would normally not be permitted. Since VLANs are often used for isolation, this may allow an attacker to view or communicate with sensitive machines.

Address Resolution Protocol (ARP) Poisoning While technically a Layer 3 attack, mitigation is often the responsibility of switches on the network. This attack allows an attacker to falsify ARP tables by sending forged packets, which causes clients to forward packets to the wrong MAC address for a specified IP address. This can be used to Man-in-the-Middle (MitM) traffic bound for a specific host — including a gateway router — to observe traffic.

Mitigations ########### 

These attacks can be mitigated in various ways, some of which are covered in later lessons. A general overview of the mitigations for each of these follows:
MAC Flooding/Spoofing Mitigations for these attacks depend on the network configuration. If MAC addresses are known, each port can be configured with a whitelist of each address allowed on that port. Alternately, authentication in some manner — such as AAA or 802.1x — can be used to ensure that only approved devices are allowed to connect to ports or wireless for Wireless Fidelity (Wi-Fi) switches

VLAN Hopping VLAN hopping can be mitigated via appropriate port configurations. Enforcing correct settings here involves ensuring that client ports are set to access only, disabling trunk auto-negotiation on client ports, and ensuring that the native VLAN for client ports is set to an inaccessible VLAN. More details about these attacks and their mitigations are covered in the VLAN Attacks and Defenses lesson.

ARP Poisoning ARP Poisoning attacks can be mitigated in several ways, depending on the network and its configuration. Mitigating these attacks generally involves switch and/or router configuration. Wi-Fi-based mitigation can be accomplished via client isolation, which prevents Wi-Fi clients from sending ARP packets to each other; wired-based mitigation can involve rate-limiting, manually binding important IP addresses to specific ports, or using vendor-specific, anti-spoofing technology that validates ARP packets by validating against known hosts and blackholing unknown hosts that attempt to duplicate IP addresses. More details about these attacks and their mitigations are given in the MitM Attacks and Defenses lesson.



The original STP is from IEEE's 802.1D standards and supports ensuring a loop-free topology for one VLAN. Therefore, this topic is vital to understand as a foundation for learning how the other STP iterations operate.

802.1D Port States

In the 802.1D STP protocol, ports transition through the following states:

Disabled: The port is in an administratively disabled configuration (shut down).

 Blocking: The state right after the switch port is enabled. The port does not forward any traffic, which ensures that no loop is created. The switch in this state does not modify the MAC address table, and it only receives BPDUs from other switches.

 Listening: The switch port has transitioned out of the blocking state and sends/receives BPDUs. At this point, it cannot transmit any other network traffic. The duration of the listening state correlates to the STP forwarding time. 

 Learning:  While the switch port is in this state, the switch can modify the MAC address table with traffic that it receives. The switch port — up to this point — only forwards BPDUs. The duration of the learning state correlates to the STP forwarding time.

Forwarding: The switch can update the MAC address table, and the switch port can forward all network traffic. During normal operations, the switch port stays in the forwarding state. 

 Broken: The switch has detected a problem on a port that can have a significant impact. The port drops packets as long as the situation persists.

Spanning Tree Port Types


The 802.1D STP standard defines three port types:
Root Port (RP): Each VLAN should only have one associated RP on a switch. The RP is a switch port that connects directly to the root bridge or an upstream switch in the spanning-tree topology. Designated Port (DP): There should be only one active designated port on a link. A DP is a switch port that receives and forwards BPDU frames to other switches and connects to downstream devices and other switches. Blocking port: A port that is not forwarding traffic because of STP calculations.


STP Key Terminology


There are several key terms related to the STP:
Root bridge: Most critical switch in the Layer 2 topology. All switch ports are in a forwarding state. Therefore, the Root Bridge is considered the top of the spanning tree for all path calculations by other switches. BPDU: A BPDU default destination MAC address is the multicast address 01:80:c2:00:00:00. They are used by switches to build and notify of changes in the STP topology. Two types of BPDUs exist:Configuration BPDUs: Used to identify the root bridge, root ports, designated ports, and blocking ports. The configuration BPDU contains the following fields: root path cost, root bridge identifier, local bridge identifier, max-age, hello time, forward delay, and STP type.Topology Change Notification (TCN) BPDU: Used to notify other switches of the Layer 2 topology changes.
Root Path Cost: Combined cost of a specific path to the root switch.System priority: A 4-bit value with a default value of 32,768. Determines the priority for a switch to be the root bridge.System ID extension: A 12-bit value indicating the VLAN that a BPDU belongs to. The system priority and ID extension combine to form the switch's root bridge identification.Root bridge identifier: Combination of the root bridge system MAC address, system ID extension, and system priority. Represented as system priority value added to the system ID extension value and resulting value concatenated with the root bridge system MAC address.Local bridge identifier: Combination of the local switch's bridge system MAC address, system ID extension, and system priority. Represented as system priority value added to the system ID extension value and resulting value concatenated with the root bridge system MAC address.Max-age: With a default value of 20 seconds, this is the time threshold before a bridge port saves its BPDU information. If a switch loses contact with the switch that originated the BPDU, the BPDU is still valid until the Max-Age timer expires.Hello time: Interval in which a BPDU is transmitted out of a port. The Hello Time default value is two seconds, though the value can be configured anywhere between 1–10 seconds.Forward delay: Interval a port stays in the listening and learning states. The Forward delay default value is 15 seconds, though this value can be configured to a value between 4–30 seconds.
NOTE: STP was developed before modern switches existed. Ethernet bridges were the early adopters of the STP. Switches today perform the same role as bridges at a much higher speed and scale. The terms bridge and switch are interchangeable in this lesson.


A TAP — sometimes called a Test Access Point 

In-band TAP

Setting up in-band — or inline — ensures no traffic is lost when dealing with a switch/router that has a larger traffic throughput. The network TAP is placed in line with the communication chain of the network (e.g., a device placed between two devices such that the original physical connection between the two devices is interrupted by the TAP, 

Out-of-band TAP

Operating out-of-band, the TAP/stack operates on its own network, receiving the mission network's traffic via one or more Switched Port Analyzer (SPAN) ports from devices on the network. A downside to running out-of-band, however, is that SPAN ports can become overwhelmed in some circumstances. 

########## mod 10 lesson 2 ###############
######### Routing ##########

image saved : ospf costvalues
image saved : lsa type chart
image saved : link type
image saved : bgp states
image saved : BGP Attribute List:
image saved :
image saved :
image saved :


 Link-State protocols send information about directly connected links to all routers in the network and updates consist of only those links that have changed.

 RFC 2328, OSPF is an Interior Gateway Protocol (IGP) used to distribute routing information in a single Autonomous System (AS). 

OSPF uses the shortest path first algorithm to build and calculate the optimal path to all known destinations. The optimal path is calculated with the use of the Dijkstra algorithm. These next steps are a simplified way of looking at the algorithm's operation:

1. On startup or when there is any change in routing information, a router generates a link-state advertisement. This advertisement represents the combination of all link-states on that router.

2. All routers exchange link-states by flooding link-states to all neighboring routers. Each router that receives a link-state update stores a copy in its link-state database and then advertises the update to other neighboring routers.

3. After each router completes building its database, the router calculates a Shortest Path Tree to all learned destinations. The router uses the Dijkstra algorithm to build the IP routing table, also referred to as the Routing Information Base (RIB).

4. If no changes in the OSPF network occur, such as the cost of a link or a network being added or deleted, OSPF only exchanges Hello packets. Any changes that occur are advertised through link-state packets, and the Dijkstra algorithm is recalculated to find the shortest path.

The algorithm places each router at the root of a tree and calculates the shortest path to each destination based on the cumulative cost required to reach that destination. Thus, each router has its own topology view even though all the routers build their shortest path tree using the same link-state database. The following sections cover the steps involved in building a shortest path tree.


This exact process is repeated to elect the BDR. Suppose there is a tie, the router with the highest router-ID wins. The default priority for an OSPF interface is one.

The adjacency building starts after multiple phases have been completed. Routers that become adjacent have the same LSDB. The following is a summary of the states an interface passes through before becoming adjacent to another router:

Down: No information has been received from a router on the network segment.
Attempt: On non-broadcast multi-access clouds such as X.25 and Frame Relay, the Attempt state indicates that no recent information has been received from a neighbor. An effort should be made to contact the neighbor by sending Hello packets at the reduced rate Poll Interval.
Init: The interface has detected a Hello packet coming from a neighbor, but bi-directional communication has yet to be established.
Two-way: Bi-directional communication has been established with a neighbor. The router has seen its router-ID in the Hello packets received from a neighbor. At the end of this stage, the election of a DR and BDR would have completed. Once the Two-way stage is completed, routers decide whether to proceed in establishing adjacency or not. This decision is based on whether one of the routers is a DR or BDR; or if the link is a virtual link or point-to-point.
Exstart: OSPF routers are trying to establish the initial sequence number that is used in the information exchange packets. This sequence number ensures that routers always receive the most up-to-date information. One router becomes the primary, the other secondary. The primary router proceeds to poll the secondary for information.
Exchange: OSPF routers report their entire link-state database by sending database description packets to all interfaces referenced in the OSPF network command. At this state, packets can be flooded to other interfaces on the router.
Loading: At this state, routers are completing information exchange. OSPF routers have built a link-state retransmission list and a link-state request list. Any incomplete or outdated information is added to the request list. Transmitted updates are added to the retransmission list until they get acknowledged.
Full: At this state, adjacency is complete. Neighboring routers are fully adjacent. Therefore, adjacent routers operate with a similar link-state database.

 for example, to set the metric for redistributed routes. General rules for route-maps are as follows:
Each route-map command must have a uniquely configured name. All commands that use the same name are a part of the same route-map.
Each route-map command has an associated permit or deny action.
Each command in the same route-map has a unique sequence number; this allows for the deletion and insertion of single route-map commands.
When a route-map is used for route redistribution, the route-map processes routes taken from the current routing table.
Route-maps are processed sequentially based on their sequence numbers.
If a route is matched in a route-map statement and the route-map statement has a deny action, the route is not redistributed (specific to route redistribution).

Brief sample of a route-map managing the redistribution of static routes into OSPF process 1, though OSPF is used in this example, route-maps can be used by all routing protocols. 


ip route 172.16.0.0 255.255.255.0 172.17.1.1
ip route 192.168.11.0 255.255.255.0 172.17.1.129
!
ip prefix-list connected-to-ospf seq 5 permit 172.16.0.0/24
!
route-map connected-to-ospf permit 10 
 match ip address prefix-list connected-to-ospf
 set metric 100
!
router ospf 1
 redistribute static subnets route-map connected-to-ospf



Breaking down the sample configuration:
Router is hosting two static routesA prefix-list has been created to define (control) the route to be redistributedThe route-map has been created with a unique name, sequence number, and actionIn the route-map, the match statement refers to the prefix-list with the prefix of the static route is redistributedThe route-map also defines that all routes that match are redistributed with a metric of 100
In OSPF 1 process the route-map is controlling the redistribution. Route 172.16.0.0/24 is redistributed with a metric of 100Route 192.168.11.0/24 is denied by the route-map
NOTE: Managing inbound and outbound route redistribution is a key control to mitigating malicious activity attempting to leverage routing domains. This method also provides network administrators and security practitioners an additional means of access control by limiting how routes propagate throughout the routing domain. 



Border Gateway Protocol ###################

Border Gateway Protocol (BGP) — classified as an Exterior Gateway Protocol (EGP) — is the premier protocol used throughout the Internet and large-scale enterprise networks for routing between autonomous systems. 


Path Attributes


Assigned variables that BGP routers use to choose an optimal path to a destination. Some of the attributes of the path listed in the Looking Glass Server output are:
MED
LOCAL_PREF
ORIGIN
AS_PATH
WEIGHT
NEXT_HOP

BGP Main Characteristics


BGP is a path-vector protocol with the following characteristics:
Relies on TCP port 179 to transfer data providing reliable delivery of BGP updates.
Only sends updates when a path change occurs (no periodic updates).
The protocol uses path vector or attributes to determine optimal paths.
Utilizes a keepalive message to verify and maintain TCP connection with neighbors.


 An Autonomous System (AS) is a collection of IP networks and routers under the control of one or a few network operators that has a single, clearly defined routing policy.

Autonomous System Number (ASN) Ranges


ASNs — similar to IP addresses — operate with public and private ranges. ASNs were also recently expanded to address the exhaustion of the two-octet AS numbers.
0-65535 (initial 16-bit ASNs)
65536-4294967295 (new range for 32-bit ASNs) (RFC 4893)

ASN Assignments
0 and 65535 (reserved)
1-64495 (public range)
65552-4294967295 (public range)
64512-65534 (private range)
23456 (reserved to represent 32-bit ASN on devices that only support 16-bit ASNs - represented as AS_TRANS) (RFC 4893)


BGP Table
List of networks received from each neighbor — Network Layer Reachability Information (NLRI)
It might contain multiple paths to a destination network
Contains BGP path attributes

Routing Table
Often referred to as the Routing Information Base (RIB), it contains the list of the best routes to destination networks
If there are multiple paths to a destination, the router advertises only the best path from the BGP table to its peers rather than all available paths.

goal for BGP routers is to reach the ESTABLISHED state. In this state, the routers have established a TCP connection, exchanged OPEN messages, and all parameter checks have passed, at which point topology information can be exchanged using UPDATE messages.

BGP Neighbor Relationship
To establish peering, each BGP router must be manually configured to enable the BGP process. When a neighbor is added to the local router configuration, the neighbor's AS must also be included.

iBGP neighbors: A router that is in the same AS as the local router. When added to the local router configuration, the neighbors share the same ASN.

eBGP neighbor: A router that is in a different AS of the local router. When added to the local router configuration, the neighbor is configured with its ASN.

The type of BGP neighbor has little effect on BGP neighbor peering establishment. However, more significant differences between neighbor types appear in the process of sending BGP updates and adding routes to the routing table.

During the neighbor relationship establishment, BGP performs the following checks:
-The router must receive a TCP layer connection request on port 179 with the sender's address, which the router finds specified in the list of neighbors configured.
-The ASN of the local router must match the ASN that is configured on the neighboring router in the neighbor remote-as command. There are exemptions to this requirement when ASs are operating in a confederation setting. Confederations are outside of the scope of this lesson but are briefly covered later. 
- The neighbor's router ID should not match that of the local router.
- If configured, MD5 authentication must be completed successfully.

BGP performs keepalive and hold timer checks; however, the difference of these parameters does not affect the neighbor relationship establishment. If timers do not match, then each router uses the smaller value of the hold timer.


Although the configuration between the two methods of deploying BGP is minor, they have slight differences in how they operate:
Packets sent to eBGP peers use a Time to Live (TTL) of 1.The NEXT_HOP attribute is updated with the last eBGP peer. This does not occur in an iBGP process.eBGP neighbors do not advertise routes to eBGP neighbors in an AS that is contained within the AS_PATH.iBGP routes Administrative Distance (AD) is 200; eBGP routes AD is 20.iBGP routes are subject to BGP synchronization (when enabled).

The timers bgp 3 15 command makes the router send KEEPALIVE message every three seconds and use a hold timer of 15 seconds by default. For the peering configuration with neighbor 200.200.2.1, a keepalive interval of ten seconds is used, and a hold time of 30 seconds. If there is a difference between BGP peers timers configuration, the lower timer setting is adopted.
Keepalive Interval: Time interval (in seconds) between sending KEEPALIVE messages.Hold Time: Time interval (in seconds) after which the neighbor is considered unreachable.

Marker — Field included in the header for compatibility, synchronization, and authentication. The size of the field – 16 bytes.

Length — Total length of the message in bytes, including the fields of the header. The minimum value of this field is 19 bytes for a KEEPALIVE message and may go as high as 4096 bytes.


Type — Type of message sent:
Type 1 - OPEN
Type 2 - UPDATE
Type 3 - NOTIFICATION
Type 4 - KEEPALIVE

Message Type 1 — Open
Here is a brief explanation of the function of each field:
Version: BGP protocol version.My Autonomous System: ASN source.
Hold Time: The maximum time (seconds) can elapse between receiving the KEEPALIVE and UPDATE message.BGP Identifier: Contains the BGP Router-ID (RID). A 32-bit unique number that identifies the BGP router in the advertised prefixes as the BGP Identifier. Typically represented by an IPv4 address that resides on the router.Optional Parameters Length: If the field is 0, the marker is set to 1, and Optional Parameters have zero length. If the field is different from 0, data necessary to determine the specified code in the marker field is recorded in the Optional Parameters.Optional Parameters: Plays a role in forming and identifying the code in the marker field.


Path Attributes
There are four categories of Path Attributes:

Well-known mandatory – BGP attributes that must be recognized by all BGP routers, present in all BGP updates, and passed on to other BGP peers.
Well-known discretionary – BGP attributes all BGP routers must recognize by all BGP routers that and passed on to other BGP peers but do not need to be present in an update.
Optional transitive – BGP attributes that might or might not be recognized by a BGP router but passed on to other BGP peers. If not recognized, it is marked as partial.
Optional non-transitive – BGP attributes that might or might not be recognized by a BGP router and not passed on to other peers.




########## mod 10 lesson 3 ###############
######### Protocol Basics ##########

all we did was wireshark



########## mod 11 lesson 1 ###############
######### Microsoft Communication Protocols ##########

image saved : netbios hex sufix
image saved : zeeklogs
image saved : windows login event id
image saved : 
image saved : 
image saved : 

Microsoft uses a layered approach to networking with each layer supporting the ones above and below. Very simplistically:
- Windows applications call high-level networking APIs, like WinHTTP
- High-level APIs use the Winsock API to package up the data and decide which transport protocols to use and the associated addressing used for those transport protocols
- One or more LSPs process the data and pass it to the corresponding TSP
- The TSP then interfaces with the kernel drivers and APIs to actually craft packets and frames, and send out over the physical medium

Winsock is based on the Berkeley Software Distribution (BSD) Sockets API that became the standard for UNIX systems.

A client using the Winsock API uses the following sequence and function calls to send and receive network traffic:
Calls a Winsock initialization function
Creates a socketCalls getaddrinfo to obtain the address of the server it wants to connect to (such as an Internet Protocol version 4 [IPv4] address)
Calls connect — includes the server address/port returned from getaddrinfo — to start a connection
Calls send and recv to send and receive data across the socket

A server using the Winsock API uses the following sequence to send and receive network traffic:

Calls a Winsock initialization function
Creates a socket
Binds the new socket to listen on a local address using bind. The address (local interface — or all interfaces — and a port number for TCP and UDP) it binds to is usually pre-defined and does not change so that clients always know how to connect to that server application (for example HTTP usually binds to TCP port 80)
For connection-oriented services (e.g., TCP, Sequenced Packet Exchange [SPX]) the application performs a listen with a backlog (the number of connections the server asks Winsock to hold in reserve until it is able to accept them)
Call accept, which waits for a connection from a client, and will create a new socket for the connection  between the server and client, and leaves the original socket still listening for new connections
Calls send and recv to send and receive data across the socket

The SMB protocol is a network file and resource sharing protocol that was originally introduced in the 1980s with SMBv1. Since then, the SMB protocol has evolved multiple times and seen more recent versions that include end-to-end SMB encryption — introduced in SMBv3 for Windows 8 and Server 2012. SMBv3.1.1 is the latest version and was introduced for Windows 10 and Server 2016. 

Remote desktop access is often used by system administrators to see the same screen that a user is seeing to better troubleshoot any issues they are having. It can mirror a user’s desktop windows, or provide the same windowed experience a user normally has from a traditional computer in a remote location. There are three main applications that can be used within Windows to make RDP connections to remote systems: Remote Desktop Connection tool (mstsc.exe), Remote Desktop Connection Manager (RDCMan), and the Remote Desktop universal app found on the Microsoft Store. Microsoft RDP uses TCP port 3389 for remote desktop connections. This port should not be exposed to the internet or have port-forwarding enabled from an internet-facing device to internal hosts. For RDP connections originating outside an enterprise network, sound security practices involve establishing a Virtual Private Network (VPN) connection — or other secure tunnel — to an internal network and then using RDP clients to make connections in that isolated environment. RDP uses Microsoft's normal authentication protocols and procedures to control access — typically Kerberos in modern networks — and has logs and events associated with account logon and logoff as a typical user has. 


########## mod 11 lesson 2 ###############
######### Network Security Devices (CUI) ##########

image saved : suricata levels
image saved : 
image saved : 
image saved : 
image saved : 
image saved : 
image saved : 
image saved : 



Firewalls operate across the Open Systems Interconnect (OSI) model’s layers, typically from the network layer to the application layer. There are four main types of firewalls:
Packet filtering firewall (stateless): Operates at the network layer and compares incoming and outgoing packets to ACL. These ACLs are basic and typically only include Internet Protocol (IP) addresses, protocols, ports, and an action such as approve or deny. Each packet is checked against the rule without any additional tracking of connections or state.
Circuit-level gateways: Similar to packet filtering firewalls, except they check the session-level protocols for a valid connection. They typically operate on User Datagram Protocol (UDP) and Transport Control Protocol (TCP) and create a virtual circuit with the internal host. The connection to the external host appears to come from the gateway. This is similar to how Network Address Translation (NAT) and Port Address Translation (PAT) function, except the gateway creates a separate connection and ensures a connection is valid before continuing to forward packets.
Stateful inspection firewall: Similar to packet filtering firewall, except they also keep track of established connections and create dynamic rules based on a state table. The state table is built when a connection is completed (using a connection-based protocol like TCP) and includes the source and destination IP addresses and ports. A dynamic rule is added to allow packets that match an established connection’s state and drops packets that are not part of an established connection. Due to the increased processing of the packets/sessions, they consume more resources than packet filtering firewalls and circuit-level gateways.
Application-level gateway (proxy firewalls): Similar to circuit-level gateways, but provide much deeper inspection, including the same functions as a stateful firewall. The internal and external hosts do not directly connect, instead there are separate connections made to the proxy. The proxy performs state inspection and has complete access to the communication so rules can be very specific about the internals or details of the data traversing the proxy. This is also called deep-packet inspection. Deep-packet inspection can be bypassed or enabled based on conditions set by the administrator. The more processing of a packet/session a proxy conducts, the more processing power and resources it requires, which can be a significant bottleneck for network throughput.


Vendors also market next-generation firewalls, which do not have a standard, so the features they employ are dependent on what the vendor implements. These next-generation firewalls are operating at the application-level like proxy firewalls. Additional features a next-generation firewall employs may include:

Zero-trust sandboxing: Placing devices in an isolated enclave until certain security checks have been completed (e.g., antivirus scan, patch scan, etc.)

Role-based: Specify rules based on a configured role assigned to a user (e.g., only certain users can connect with wireless devices)

Artificial Intelligence (AI)/Machine Learning (ML): May use AI/ML to dynamically create rules to allow or block traffic

Secure Sockets Layer (SSL)/Transport Layer Security (TLS) decryption: Requires internal clients to create an encrypted connection with the proxy, which creates a separate encrypted connection to the external host. This allows the device to decrypt and inspect data traversing the proxy (very resource intensive).

IDS/IPS functions: May include IDS (passive) or IPS (active) defenses instead of using a separate device or server


Suricata


Suricata is an open-source Network Security Monitoring (NSM) solution that can be used as a NIDS and an IPS. Suricata uses rules to perform actions — like alerting a security analyst — on live or recorded Packet Capture (PCAP) data. The rule format Suricata uses is compatible with other NSM applications — including Snort — and also supports the Lua scripting language to extend processing and alerting beyond the traditional rules format. While Snort has been around longer than Suricata, Suricata has several features that are not currently available in Snort. Suricata features include:
Multithreaded: Supports running many threads to take advantage of multi-core Central Processing Units (CPU)
Hardware acceleration: Supports using graphics cards to process and inspect network traffic
File extraction: Supports recognizing, extracting, and saving files from network traffic
Scripting: Uses the Lua scripting language

The Suricata documentation includes the full feature set.

Security Onion and Suricata


Suricata is often deployed as part of the Security Onion (SO) suite. SO has three alerting engines: Suricata, Wazuh, and Playbook. Each of these engines has its own alerting system and severity, which SO converts into a standard level:



ET - Suricata rule
GPL - SNORT rule

Suricata rules are comprised of three parts:
Action: What happens when the signature matches
Header: Describes the protocol, IP address, ports, and network flow direction of the rule
Rule options: Specifics of the rule



t needs to be placed inline with the network it is protecting, as discussed in earlier lessons. The actions available are:
alert: Generates an alert; the only option available in a passive role
pass: Stops further inspection of the packet; typically because it is expected or not suspicious
drop: Drops the packet and generates an alert; similar to a firewall that drops a packet
reject: Sends a packet with the RST flag and/or an ICMP unreachable packet to the sender — originator — of the matching packet; this closes any TCP session in the process of being setup
rejectsrc: Same as reject
rejectdst: Sends a RST/ICMP unreachable to the destination host; the matching packet was addressed
rejectboth: Sends a RST/ICMP unreachable to both sides of the conversation

Rule Options



The Options section of a Suricata rule is composed of keywords and settings. Not all keywords have settings, but there may be multiple settings separated by commas — keywords are separated by semicolons. In Figure 11.2-18, the keywords are:
msg: The alert message associated with this rule
flow: flow:to_server matches packets from a client to a server
flags: flags:S,12 matches TCP SYN packets or TCP packets with the two reserved bits set
threshold: A threshold used to control the rule’s alert frequency
threshold:type both, track by_src, count 5, second 120 only alerts when a threshold of five matched packets from the same source IP address is exceeded within 120 seconds and only alerts five times in 120 seconds. The threshold: type setting has three options:threshold: Only alerts when the count setting is exceeded in the second time periodlimit: Only alerts count number of times in the second time periodboth: Only alerts when the count setting is exceeded in the second time period and alerts at maximum count times in the second time period

reference: A reference to where more information about the signature/alert can be foundclasstype: Classification of the rule and alert; consists of a short name, and optionally, a long name, and prioritysid: Signature Identifier (ID)rev: Revision of the signaturemetadata: Additional non-functional information about the signature
Keywords can be negated using the exclamation point (!) prior to the keyword to negate:


SO holds all rules in the /opt/so/rules/nids directory

OT networks often use bus- and serial-related protocols to communicate among devices, but also typically have some management bridge between the OT segment and one or more devices on a TCP/IP protocol stack. OT is used to refer to a variety of networks including: 

SCADA
ICS
Distributed Control Systems (DCS)
Programmable Logic Controllers (PLC)
Shipboard Hull Mechanical and Electrical (HM&E)
Remote Terminal Units (RTU)


Many of the OT network protocols are built on proprietary equipment manufacturer requirements and may not be documented or publicly available. Some of the more common OT network protocols include: 

DNP3
Modbus
Process Field Bus (Profibus)
Local Operating Network (LonWorks)
Digital Addressable Lighting Interface (DALI)
Building Automation and Control Network (BACnet)
Konnex (KNX)



########## mod 11 lesson 3 ###############
######### Logical Network Maps ##########

image saved : 
image saved : 
image saved : 
image saved : 
image saved : 
image saved : 
image saved : 

























